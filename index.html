<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye Tracking 3D Objects</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #video { display: none; }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 150px;
            border: 2px solid #fff;
            z-index: 10;
            transform: scaleX(-1);
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted></video>
        <canvas id="canvas"></canvas>
        <div class="loading" id="loading">Loading MediaPipe...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <script>
        // Three.js setup
        let scene, camera, renderer;
        let objects = [];
        let eyePosition = { x: 0, y: 0, z: 50 };
        let smoothedEyePosition = { x: 0, y: 0, z: 50 };
        const smoothingFactor = 0.15;
        let lastTime = 0;
        let frameCount = 0;

        // Screen dimensions (you may need to adjust these for your setup)
        const SCREEN_WIDTH_CM = 35; // Approximate laptop screen width in cm
        const SCREEN_HEIGHT_CM = 20; // Approximate laptop screen height in cm
        const IRIS_DIAMETER_MM = 11.7;

        // MediaPipe setup
        let faceMesh;
        let videoElement;
        let canvasElement;

        function init() {
            const container = document.getElementById('container');
            canvasElement = document.getElementById('canvas');
            videoElement = document.getElementById('video');

            // Three.js scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Create geometric objects
            createObjects();

            // Setup MediaPipe
            setupMediaPipe();

            // Start render loop
            animate();
        }

        function createObjects() {
            // Create multiple objects at different depths for 3D parallax effect
            const geometries = [
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.ConeGeometry(1, 3, 8),
                new THREE.OctahedronGeometry(1.2),
                new THREE.TorusGeometry(1.2, 0.4, 16, 100),
                new THREE.CylinderGeometry(0.8, 0.8, 2.5, 16),
                new THREE.DodecahedronGeometry(1.3),
                new THREE.TetrahedronGeometry(1.8)
            ];

            const materials = [
                new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0x44ff44, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0x4444ff, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0xffff44, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0xff44ff, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0x44ffff, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0xff8844, shininess: 100 }),
                new THREE.MeshPhongMaterial({ color: 0x8844ff, shininess: 100 })
            ];

            // Create objects at different depths and positions
            for (let i = 0; i < 8; i++) {
                const mesh = new THREE.Mesh(geometries[i], materials[i]);
                
                // Arrange in multiple layers
                const angle = (i / 8) * Math.PI * 2;
                const radius = 6 + (i % 2) * 3;
                const depth = -10 - (i % 3) * 8; // Different depths: -10, -18, -26
                
                mesh.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius * 0.5,
                    depth
                );
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Store original position for parallax calculations
                mesh.userData.originalPosition = mesh.position.clone();
                mesh.userData.depth = depth;
                
                scene.add(mesh);
                objects.push(mesh);
            }

            // Enhanced lighting for better visuals
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Add colored accent lights
            const redLight = new THREE.PointLight(0xff4444, 0.5, 30);
            redLight.position.set(-10, 5, -10);
            scene.add(redLight);
            
            const blueLight = new THREE.PointLight(0x4444ff, 0.5, 30);
            blueLight.position.set(10, -5, -20);
            scene.add(blueLight);

            // Add multiple ground planes at different depths for depth perception
            for (let i = 0; i < 3; i++) {
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const brightness = 0.2 + (i * 0.1);
                const groundMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(brightness, brightness, brightness),
                    transparent: true,
                    opacity: 0.3 + (i * 0.2)
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -8 - (i * 3);
                ground.position.z = -15 - (i * 10);
                ground.receiveShadow = true;
                scene.add(ground);
            }
            
            // Add some floating particles for atmosphere
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6 
            });
            
            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 20,
                    -5 - Math.random() * 40
                );
                particle.userData.originalPosition = particle.position.clone();
                particle.userData.depth = particle.position.z;
                scene.add(particle);
                objects.push(particle);
            }
        }

        function setupMediaPipe() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            // Setup camera
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await faceMesh.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            camera.start();

            document.getElementById('loading').style.display = 'none';
        }

        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Calculate eye position using iris landmarks
                calculateEyePosition(landmarks);
                updateCamera();
                
                // Info display removed for clean presentation
            }
        }

        function calculateEyePosition(landmarks) {
            // Use face width for distance calculation (more reliable than iris)
            // Face landmarks: left face edge (234) to right face edge (454)
            const leftFace = landmarks[234];
            const rightFace = landmarks[454];
            const faceWidthPixels = Math.abs(rightFace.x - leftFace.x) * videoElement.videoWidth;
            
            // Average face width is approximately 14cm
            const averageFaceWidthCM = 14;
            const focalLength = 600; // Typical webcam focal length in pixels
            const distance = (averageFaceWidthCM * focalLength) / faceWidthPixels;

            // Use nose tip for head position tracking (more stable)
            const noseTip = landmarks[1]; // Nose tip landmark
            
            // Convert head position to world coordinates
            // Flip X coordinate because camera is mirrored
            const newX = -(noseTip.x - 0.5) * SCREEN_WIDTH_CM * 1.5;
            const newY = -(noseTip.y - 0.5) * SCREEN_HEIGHT_CM * 1.5;
            const newZ = Math.max(30, Math.min(150, distance));
            
            // Apply smoothing to reduce flickering
            smoothedEyePosition.x += (newX - smoothedEyePosition.x) * smoothingFactor;
            smoothedEyePosition.y += (newY - smoothedEyePosition.y) * smoothingFactor;
            smoothedEyePosition.z += (newZ - smoothedEyePosition.z) * smoothingFactor;
            
            eyePosition = { ...smoothedEyePosition };
        }

        function updateCamera() {
            // Position camera at eye position
            camera.position.set(eyePosition.x, eyePosition.y, eyePosition.z);
            
            // Create off-axis projection matrix
            const left = -SCREEN_WIDTH_CM / 2 - eyePosition.x;
            const right = SCREEN_WIDTH_CM / 2 - eyePosition.x;
            const bottom = -SCREEN_HEIGHT_CM / 2 - eyePosition.y;
            const top = SCREEN_HEIGHT_CM / 2 - eyePosition.y;
            const near = 0.1;
            const far = 1000;

            camera.projectionMatrix.makePerspective(
                left * near / eyePosition.z,
                right * near / eyePosition.z,
                top * near / eyePosition.z,
                bottom * near / eyePosition.z,
                near,
                far
            );

            // Create parallax effect - objects at different depths move differently
            objects.forEach((obj, index) => {
                if (obj.userData.originalPosition && obj.userData.depth) {
                    // Calculate parallax factor based on depth (closer objects move more)
                    const parallaxFactor = 1.0 / (Math.abs(obj.userData.depth) / 10);
                    
                    // Apply head movement with parallax
                    const targetX = obj.userData.originalPosition.x + (eyePosition.x * parallaxFactor * 0.4);
                    const targetY = obj.userData.originalPosition.y + (eyePosition.y * parallaxFactor * 0.4);
                    
                    // Smooth movement
                    obj.position.x += (targetX - obj.position.x) * 0.08;
                    obj.position.y += (targetY - obj.position.y) * 0.08;
                    
                    // Different rotation speeds for variety
                    obj.rotation.x += 0.003 + (index % 3) * 0.002;
                    obj.rotation.y += 0.003 + (index % 4) * 0.002;
                    obj.rotation.z += 0.001 + (index % 2) * 0.001;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate FPS (for internal tracking only)
            const currentTime = performance.now();
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                frameCount = 0;
                lastTime = currentTime;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
